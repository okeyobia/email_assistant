## Email Assistant CLI

A Gmail-integrated command-line assistant that fetches unread messages, classifies them via keyword rules (and optional ML), and applies Gmail labels automatically.

### Key Features
- OAuth2 authentication with the Gmail API (google-auth, google-api-python-client)
- Fetch + inspect unread messages directly from the CLI, now with inline sentiment analysis
- Rule-based labeling with customizable keywords stored in `rules/rules.json`
- Strategy-based labeling engine that can mix rules with ML predictions
- Optional ML classifier hook (scikit-learn pipeline or transformers model)
- Automatic label creation + SQLite-backed deduplication to avoid relabeling the same email twice
- Dry-run mode for safe previews and per-account activity tracking + logging
- Background scheduling via the `schedule` library and ready-to-run Dockerfile

### Project Layout
```
main.py              # Click-powered CLI entry point
services/            # Gmail API wrapper, auth, classifiers, stats store
utils/               # Config loader, logging config, rules engine
models/              # Typed data containers for emails + rules
rules/rules.json     # Default keyword rules
data/stats.json      # JSON stats file (autogenerated)
logs/                # Rotating log files (autogenerated)
```

### Requirements
- Python 3.11+
- uv (https://github.com/astral-sh/uv) for dependency & script management
- Gmail API enabled on a Google Cloud project with OAuth client credentials

### Setup
1. **Clone & enter the project**
	```bash
	git clone <repo-url> email_assistant
	cd email_assistant
	```

2. **Install dependencies**
	```bash
	uv sync           # installs core dependencies into .venv
	uv sync --all-extras  # optional: include the ML extras
	```

3. **Create OAuth credentials**
	- In Google Cloud Console, enable the Gmail API.
	- Create an OAuth 2.0 Client ID (Desktop) and download the JSON file.
	- Save it in the project root as `credentials.json` (or update `.env`).

4. **Configure environment variables**
	```bash
	cp .env.example .env
	# edit .env with your paths + desired defaults
	```
	- For multiple Gmail accounts, duplicate `accounts.sample.json`, rename to `accounts.json`, and update the credential/token paths for each profile. Reference an account with `--account work` on any CLI command.

5. **Run an initial OAuth flow**
	```bash
	uv run email-assistant fetch
	```
	- A browser window will prompt you to authorize the Gmail scopes.
	- `token.json` will be generated and cached for future runs.

### CLI Usage
| Command | Description |
| --- | --- |
| `uv run email-assistant fetch --max-results 10` | Print a table of unread emails |
| `uv run email-assistant label --max-results 25 --dry-run` | Preview the labels that would be applied |
| `uv run email-assistant create-label "Finance"` | Ensure a label exists in Gmail |
| `uv run email-assistant stats` | Show local action counters |
| `uv run email-assistant schedule --task label --interval 15` | Run the labeler every 15 minutes |

Use `--env-file custom.env` on any command to point to a different configuration file.
Use `--account work` (matching an entry in `accounts.json`) to switch Gmail profiles on the fly.

### Deduplication, Sentiment & Dry-Run Mode
- Processed email IDs are cached in `data/email_assistant.db` (SQLite) so each account labels an email only once.
- Add `--dry-run` to `label` (or scheduled labeling) to see which labels would be applied without touching Gmail.
- Fetch output now shows a sentiment column powered by VADER to help gauge tone at a glance.
- Credentials/tokens can be injected via environment variables (`GOOGLE_CLIENT_SECRETS_JSON` / `_B64`, `GOOGLE_TOKEN_JSON` / `_B64`). The loader writes them to disk automatically for non-interactive deployments.

### Multi-Account Configuration
- Populate `accounts.json` (see `accounts.sample.json`) with entries shaped like:
	```json
	{
		"name": "work",
		"user_id": "me",
		"credentials_file": "credentials_work.json",
		"token_file": "token_work.json"
	}
	```
- Pass `--account work` on any command (or on the scheduler) to target that profile. Stats and the SQLite processed table are namespaced per account.

### Custom Rules & ML
- Edit `rules/rules.json` to add or adjust keyword-based label rules. Each rule supports:
  ```json
  {
	 "label": "Work",
	 "keywords": ["deadline", "client"],
	 "match_subject": true,
	 "match_body": true,
	 "priority": 4
  }
  ```
- Optional ML: provide either
  - `ML_MODEL_PATH` pointing to a scikit-learn pipeline saved via `joblib.dump`
  - `TRANSFORMER_MODEL_NAME` referencing a Hugging Face text-classification pipeline
- Install ML extras with `uv sync --extra ml` (or `uv sync --all-extras`).

### Scheduling & Automation
- Use the built-in scheduler to keep the inbox tidy:
	```bash
	uv run email-assistant schedule --task label --interval 10 --max-results 50
	```
- The scheduler respects `--account` and `--dry-run` flags, printing summaries each run. Stop it with `Ctrl+C`.

### Infrastructure as Code (Terraform)
- The `terraform/` folder provisions an AWS ECS Fargate cluster, EventBridge schedule, IAM roles, CloudWatch logs, and an optional ECR repository.
- Configure the module inputs (`container_image`, `subnet_ids`, `security_group_ids`, secrets) and apply:
	```bash
	cd terraform
	terraform init
	terraform apply -var='container_image=123456789012.dkr.ecr.us-east-1.amazonaws.com/email-assistant:latest' \
									 -var='subnet_ids=["subnet-abc", "subnet-def"]' \
									 -var='security_group_ids=["sg-0123456789abcdef0"]'
	```
- Use AWS Secrets Manager / SSM Parameter Store to hold base64-encoded OAuth credentials + tokens, then map them to `secret_env` so the task sets `GOOGLE_CLIENT_SECRETS_B64` and `GOOGLE_TOKEN_B64` at runtime.
- See [terraform/README.md](terraform/README.md) for full instructions and input documentation.

### GitOps Deployment (Kubernetes + Argo CD)
- Manifests live in [deploy/](deploy) and are organized with Kustomize (`base` + `overlays/prod`). The default overlay deploys a CronJob that runs `email-assistant label --account work` every 15 minutes.
- Provide a namespace-scoped secret named `email-assistant-secrets` containing the same env variables you would define in `.env` (recommended: set base64 payloads for `GOOGLE_CLIENT_SECRETS_B64` and `GOOGLE_TOKEN_B64`).
- Point your GitOps operator at `deploy/overlays/prod`; any change merged to `main` becomes the desired state. For Argo CD, apply the sample [Application manifest](deploy/argocd/application.yaml) (replace the repo URL with your fork):
	```bash
	kubectl apply -n argocd -f deploy/argocd/application.yaml
	```
- The CI workflow updates `deploy/overlays/prod/kustomization.yaml` with the latest image digest whenever main is updated, ensuring Argo CD deploys new images automatically once the commit lands.

### CI/CD & GitOps Automation
- `.github/workflows/ci.yml` defines three jobs:
	1. **test** – installs uv, syncs deps, and runs `pytest` on every PR/push.
	2. **docker** – builds the container image (linux/amd64) and pushes `ghcr.io/<owner>/<repo>:{sha,latest}` after tests pass on `main`.
	3. **gitops** – rewrites the Kustomize overlay with the new image tag and commits it back to `main` using a Personal Access Token (PAT). The commit uses `[skip ci]` to avoid loops.
- Required GitHub secrets:
	- `GITOPS_TOKEN`: PAT with `repo` scope so the workflow can push manifest updates. (GHCR pushes use the built-in `GITHUB_TOKEN`.)
- Once Flux/Argo is configured, deployments become fully GitOps-driven: image builds update manifests, Flux/Argo notices the commit, and the cluster reconciles.

### Logging & Statistics
- Logs live under `logs/email_assistant.log` (rotating file + console output).
- Local stats live in `data/stats.json` and track overall + per-account fetch/label counts.

### Docker Usage
1. Build the image: `docker build -t email-assistant .`
2. Run it, mounting credentials/tokens/env files:
	 ```bash
	 docker run --rm -it \
		 --env-file .env \
		 -v "$PWD/credentials.json:/app/credentials.json:ro" \
		 -v "$PWD/token.json:/app/token.json" \
		 -v "$PWD/data:/app/data" \
		 email-assistant fetch
	 ```
3. Pass CLI flags at the end (e.g., `... email-assistant label --dry-run`).

### Testing
- Install dev deps: `uv sync --group dev`
- Run unit tests: `uv run pytest`
- Sample suites cover rules, strategy orchestration, and the SQLite processed-email store.

### Tips
- Run `uv run email-assistant label` via cron or a scheduler for continuous triage.
- Keep your `.env`, `credentials.json`, `token.json`, and `accounts.json` out of version control.
